import {
    existsSync,
    readFileSync,
    unlinkSync,
    writeFileSync,
} from "fs";
import ejs from "ejs";
import type { Options as EjsOptions } from "ejs";
import { isErrorOfNotFound, PagePluginConfig, ColoringConsole } from "./types";
import { EntryPath } from "./core";
import path from "path";

const _console = new ColoringConsole(1)
const GENERATED_FLAG = "<!--This is generated by vite-plugin-auto-mpa-html.-->"

export const __defaultHTMLTemplate = `<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title><%- (typeof title != 'undefined' ? title : '') %></title>
    <meta name="description" content="<%- (typeof description != 'undefined' ? description : '') %>" />
    <meta name="keywords" content="<%- (typeof keywords != 'undefined' ? keywords : '') %>" />
  </head>
  <body>
    <div id="app"></div>
  </body>
</html>`

function renderEjs(
    templateStr: string,
    data?: object,
    ejsOption?: EjsOptions
): string {
    if (data && Object.keys(data).length > 0)
        return ejs.render(templateStr, data, {
            ...ejsOption,
            async: false,
        });
    return templateStr;
}

export function fetchTemplateHTML(entry: EntryPath, pageConfig: PagePluginConfig) {
    let htmlContent;
    try {
        htmlContent = readFileSync(
            path.resolve(entry.abs, pageConfig.template || ""),
            {
                encoding: "utf-8",
            }
        );
    } catch (e) {
        if (!isErrorOfNotFound(e)) throw e;
        _console.error(`Page entry "${entry.abs}", its template cannot be found, using default template as fallback! (${e.message})`)
        htmlContent = __defaultHTMLTemplate
    }
    htmlContent = renderEjs(
        htmlContent,
        {
            ...entry.__options.sharedData,
            ...pageConfig.data,
        },
        entry.__options.ejsOption
    );
    const generatedHtml = GENERATED_FLAG.concat(htmlContent).replace(
        "</html>",
        // `<script type="module" src="${entry.__options.templateName.startsWith("/") ? `./${entry.__options.entryName}` : `./${entry.value.includes('/') ? entry.value.split('/').reverse()[0] : entry.value}/${entry.__options.entryName}`}"></script></html>`
        `<script type="module" src="${entry.abs + '/' + entry.__options.entryName}"></script></html>`
    );
    return generatedHtml
}

/**
 * generate entries for `rollupOptions.build.input`
 * @param entries {Entries}
 * @param dest {string} Output dir
 */
export function prepareTempEntries(
    entries: EntryPath[],
) {
    entries.forEach(entry => {
        let pageData: PagePluginConfig = {}
        const configPath = entry.abs + "/" + entry.__options.configName;
        if (existsSync(configPath)) {
            const tmp = readFileSync(configPath, { encoding: "utf-8" })
            pageData = JSON.parse(tmp)
        } else {
            _console.fatal(`Page entry: ${entry.value}, its config (config.json) cannot be found, please check!`)
        }
        const generatedHtml = fetchTemplateHTML(entry, pageData)
        if (existsSync(entry.abs + entry.__options.templateName)) {
            let fileContent = readFileSync(entry.abs + entry.__options.templateName, { encoding: "utf-8" });
            if(!fileContent.startsWith(GENERATED_FLAG)) {
                _console.warn(`There is a same named HTML file (${entry.__options.templateName}) already exist in entry '${entry.value}', template generation skipped`)
                return;
            }
        }
        writeFileSync(entry.abs + entry.__options.templateName, generatedHtml, {
            encoding: "utf-8",
        });
    })
}

export function prepareVirtualTempEntries(
    entries: EntryPath[],
) {
    let virtualMap = new Map<string, string>();
    entries.forEach(entry => {
        let pageData: PagePluginConfig = {}
        const configPath = entry.abs + "/" + entry.__options.configName;
        if (existsSync(configPath)) {
            const tmp = readFileSync(configPath, { encoding: "utf-8" })
            pageData = JSON.parse(tmp)
        } else {
            _console.fatal(`Page entry: ${entry.value}, its config (config.json) cannot be found, please check!`)
        }
        const generatedHtml = fetchTemplateHTML(entry, pageData)
        if (existsSync(entry.abs + entry.__options.templateName)) {
            let fileContent = readFileSync(entry.abs + entry.__options.templateName, { encoding: "utf-8" });
            if(!fileContent.startsWith(GENERATED_FLAG)) {
                _console.warn(`There is a same named HTML file (${entry.__options.templateName}) already exist in entry '${entry.value}', template generation skipped`)
                return;
            }
        }
        // writeFileSync(entry.abs + entry.__options.templateName, generatedHtml, {
        //     encoding: "utf-8",
        // });
        virtualMap.set(entry.abs + entry.__options.templateName, generatedHtml);
    })
    return virtualMap;
}

export function cleanTempEntries(
    entries: EntryPath[],
) {
    // `buildEnd` will be called even build failed, so a throttle is needed.
    if (!entries || entries.length === 0) return;
    entries.forEach(k => {
        // generate temp entries for build
        const absTemplatePath = k.abs + k.__options.templateName
        if (existsSync(absTemplatePath)) {
            const tmp = readFileSync(absTemplatePath, { encoding: "utf-8" })
            if (tmp.startsWith(GENERATED_FLAG)) unlinkSync(absTemplatePath);
        }
    });
}